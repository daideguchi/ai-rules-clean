#!/usr/bin/env node

/**
 * n8n-MCP „ÉÜ„Çπ„Éà„Çπ„ÇØ„É™„Éó„Éà
 * Êßò„ÄÖ„Å™Ê©üËÉΩ„Çí„ÉÜ„Çπ„Éà„Åó„Å¶Âãï‰ΩúÁ¢∫Ë™ç„ÇíË°å„ÅÜ
 */

const { spawn } = require('child_process');
const readline = require('readline');

class N8nMcpTester {
    constructor() {
        this.mcpProcess = null;
        this.testResults = [];
    }

    async startMcpServer() {
        console.log('üöÄ n8n-MCP „Çµ„Éº„Éê„Éº„ÇíËµ∑Âãï‰∏≠...');
        
        this.mcpProcess = spawn('npx', ['n8n-mcp'], {
            env: {
                ...process.env,
                MCP_MODE: 'stdio',
                LOG_LEVEL: 'error',
                DISABLE_CONSOLE_OUTPUT: 'true'
            },
            stdio: ['pipe', 'pipe', 'pipe']
        });

        return new Promise((resolve, reject) => {
            let output = '';
            
            this.mcpProcess.stdout.on('data', (data) => {
                output += data.toString();
                if (output.includes('MCP server started') || output.includes('ready')) {
                    resolve();
                }
            });

            this.mcpProcess.stderr.on('data', (data) => {
                console.error('stderr:', data.toString());
            });

            setTimeout(() => {
                if (this.mcpProcess.pid) {
                    resolve(); // „Çø„Ç§„É†„Ç¢„Ç¶„ÉàÂæå„Åß„ÇÇÁ∂öË°å
                } else {
                    reject(new Error('MCP server failed to start'));
                }
            }, 5000);
        });
    }

    async sendMcpRequest(method, params = {}) {
        return new Promise((resolve, reject) => {
            const request = {
                jsonrpc: '2.0',
                id: Date.now(),
                method,
                params
            };

            const requestStr = JSON.stringify(request) + '\n';
            
            let responseData = '';
            const onData = (data) => {
                responseData += data.toString();
                try {
                    const response = JSON.parse(responseData.trim());
                    this.mcpProcess.stdout.removeListener('data', onData);
                    resolve(response);
                } catch (e) {
                    // „Åæ„Å†ÂÆåÂÖ®„Å™JSON„Åò„ÇÉ„Å™„ÅÑÂ†¥Âêà„ÅØÁ∂öË°å
                }
            };

            this.mcpProcess.stdout.on('data', onData);
            this.mcpProcess.stdin.write(requestStr);

            setTimeout(() => {
                this.mcpProcess.stdout.removeListener('data', onData);
                reject(new Error('Request timeout'));
            }, 10000);
        });
    }

    async testBasicConnection() {
        console.log('\nüì° Âü∫Êú¨Êé•Á∂ö„ÉÜ„Çπ„Éà');
        try {
            const response = await this.sendMcpRequest('initialize', {
                protocolVersion: '2024-11-05',
                capabilities: {},
                clientInfo: { name: 'test-client', version: '1.0.0' }
            });
            
            console.log('‚úÖ MCPÂàùÊúüÂåñÊàêÂäü');
            this.testResults.push({ test: 'basic_connection', status: 'success' });
            return true;
        } catch (error) {
            console.error('‚ùå MCPÂàùÊúüÂåñÂ§±Êïó:', error.message);
            this.testResults.push({ test: 'basic_connection', status: 'failed', error: error.message });
            return false;
        }
    }

    async testListTools() {
        console.log('\nüîß Âà©Áî®ÂèØËÉΩ„ÉÑ„Éº„É´‰∏ÄË¶ß„ÉÜ„Çπ„Éà');
        try {
            const response = await this.sendMcpRequest('tools/list');
            
            if (response.result && response.result.tools) {
                console.log(`‚úÖ ${response.result.tools.length} ÂÄã„ÅÆ„ÉÑ„Éº„É´„ÅåÂà©Áî®ÂèØËÉΩ`);
                
                // ‰∏ªË¶Å„ÉÑ„Éº„É´„ÅÆÁ¢∫Ë™ç
                const tools = response.result.tools.map(t => t.name);
                const expectedTools = [
                    'list_nodes',
                    'get_node_info', 
                    'get_node_essentials',
                    'search_nodes',
                    'validate_workflow'
                ];

                const foundTools = expectedTools.filter(tool => tools.includes(tool));
                console.log(`üìã ‰∏ªË¶Å„ÉÑ„Éº„É´: ${foundTools.join(', ')}`);
                
                this.testResults.push({ 
                    test: 'list_tools', 
                    status: 'success', 
                    toolCount: tools.length,
                    mainTools: foundTools
                });
                return response.result.tools;
            } else {
                throw new Error('No tools found in response');
            }
        } catch (error) {
            console.error('‚ùå „ÉÑ„Éº„É´‰∏ÄË¶ßÂèñÂæóÂ§±Êïó:', error.message);
            this.testResults.push({ test: 'list_tools', status: 'failed', error: error.message });
            return null;
        }
    }

    async testNodeInfo() {
        console.log('\nüìã „Éé„Éº„ÉâÊÉÖÂ†±ÂèñÂæó„ÉÜ„Çπ„Éà');
        try {
            const response = await this.sendMcpRequest('tools/call', {
                name: 'get_node_essentials',
                arguments: {
                    nodeType: 'nodes-base.httpRequest'
                }
            });

            if (response.result && response.result.content) {
                const info = JSON.parse(response.result.content[0].text);
                console.log(`‚úÖ HTTPRequest„Éé„Éº„ÉâÊÉÖÂ†±ÂèñÂæóÊàêÂäü`);
                console.log(`üìä ÂøÖÈ†à„Éó„É≠„Éë„ÉÜ„Ç£: ${info.requiredProperties?.length || 0}ÂÄã`);
                console.log(`‚öôÔ∏è ÂÖ±ÈÄö„Éó„É≠„Éë„ÉÜ„Ç£: ${info.commonProperties?.length || 0}ÂÄã`);
                
                this.testResults.push({ 
                    test: 'node_info', 
                    status: 'success',
                    nodeType: 'httpRequest',
                    requiredProps: info.requiredProperties?.length || 0,
                    commonProps: info.commonProperties?.length || 0
                });
                return true;
            } else {
                throw new Error('Invalid response format');
            }
        } catch (error) {
            console.error('‚ùå „Éé„Éº„ÉâÊÉÖÂ†±ÂèñÂæóÂ§±Êïó:', error.message);
            this.testResults.push({ test: 'node_info', status: 'failed', error: error.message });
            return false;
        }
    }

    async testNodeSearch() {
        console.log('\nüîç „Éé„Éº„ÉâÊ§úÁ¥¢„ÉÜ„Çπ„Éà');
        try {
            const response = await this.sendMcpRequest('tools/call', {
                name: 'search_nodes',
                arguments: {
                    query: 'slack',
                    limit: 5
                }
            });

            if (response.result && response.result.content) {
                const results = JSON.parse(response.result.content[0].text);
                console.log(`‚úÖ SlackÈñ¢ÈÄ£„Éé„Éº„ÉâÊ§úÁ¥¢ÊàêÂäü: ${results.results?.length || 0}‰ª∂`);
                
                if (results.results && results.results.length > 0) {
                    results.results.slice(0, 3).forEach((node, i) => {
                        console.log(`  ${i + 1}. ${node.displayName} (${node.nodeType})`);
                    });
                }
                
                this.testResults.push({ 
                    test: 'node_search', 
                    status: 'success',
                    query: 'slack',
                    resultCount: results.results?.length || 0
                });
                return true;
            } else {
                throw new Error('Invalid search response');
            }
        } catch (error) {
            console.error('‚ùå „Éé„Éº„ÉâÊ§úÁ¥¢Â§±Êïó:', error.message);
            this.testResults.push({ test: 'node_search', status: 'failed', error: error.message });
            return false;
        }
    }

    async testWorkflowValidation() {
        console.log('\n‚ö° „ÉØ„Éº„ÇØ„Éï„É≠„ÉºÊ§úË®º„ÉÜ„Çπ„Éà');
        try {
            // „Ç∑„É≥„Éó„É´„Å™„ÉÜ„Çπ„Éà„ÉØ„Éº„ÇØ„Éï„É≠„Éº
            const testWorkflow = {
                nodes: [
                    {
                        id: 'webhook',
                        type: 'nodes-base.webhook',
                        position: [100, 100],
                        parameters: {
                            path: 'test-webhook',
                            method: 'POST'
                        }
                    },
                    {
                        id: 'http',
                        type: 'nodes-base.httpRequest',
                        position: [300, 100],
                        parameters: {
                            url: 'https://api.example.com/data',
                            method: 'GET'
                        }
                    }
                ],
                connections: {
                    webhook: {
                        main: [[{ node: 'http', type: 'main', index: 0 }]]
                    }
                }
            };

            const response = await this.sendMcpRequest('tools/call', {
                name: 'validate_workflow',
                arguments: {
                    workflow: testWorkflow
                }
            });

            if (response.result && response.result.content) {
                const validation = JSON.parse(response.result.content[0].text);
                console.log(`‚úÖ „ÉØ„Éº„ÇØ„Éï„É≠„ÉºÊ§úË®ºÂÆå‰∫Ü`);
                console.log(`üìä Ê§úË®ºÁµêÊûú: ${validation.isValid ? 'ÊúâÂäπ' : 'ÁÑ°Âäπ'}`);
                
                if (validation.errors && validation.errors.length > 0) {
                    console.log(`‚ö†Ô∏è „Ç®„É©„Éº: ${validation.errors.length}‰ª∂`);
                }

                this.testResults.push({ 
                    test: 'workflow_validation', 
                    status: 'success',
                    isValid: validation.isValid,
                    errorCount: validation.errors?.length || 0
                });
                return true;
            } else {
                throw new Error('Invalid validation response');
            }
        } catch (error) {
            console.error('‚ùå „ÉØ„Éº„ÇØ„Éï„É≠„ÉºÊ§úË®ºÂ§±Êïó:', error.message);
            this.testResults.push({ test: 'workflow_validation', status: 'failed', error: error.message });
            return false;
        }
    }

    async cleanup() {
        if (this.mcpProcess) {
            this.mcpProcess.kill();
        }
    }

    printResults() {
        console.log('\nüìä „ÉÜ„Çπ„ÉàÁµêÊûú„Çµ„Éû„É™„Éº');
        console.log('=' * 50);
        
        const success = this.testResults.filter(r => r.status === 'success').length;
        const total = this.testResults.length;
        
        console.log(`‚úÖ ÊàêÂäü: ${success}/${total} (${Math.round(success/total*100)}%)`);
        
        this.testResults.forEach(result => {
            const icon = result.status === 'success' ? '‚úÖ' : '‚ùå';
            console.log(`${icon} ${result.test}: ${result.status}`);
            if (result.error) {
                console.log(`   „Ç®„É©„Éº: ${result.error}`);
            }
        });
    }
}

async function main() {
    const tester = new N8nMcpTester();
    
    try {
        console.log('üß™ n8n-MCP Ê©üËÉΩ„ÉÜ„Çπ„ÉàÈñãÂßã');
        
        // MCPÂàùÊúüÂåñ„ÉÜ„Çπ„Éà„ÅØÁõ¥Êé•npx„Ç≥„Éû„É≥„Éâ„ÅßÂãï‰ΩúÁ¢∫Ë™ç
        console.log('\nüì° n8n-MCPÂãï‰ΩúÁ¢∫Ë™ç');
        const { spawn } = require('child_process');
        
        const checkProcess = spawn('npx', ['n8n-mcp', '--version'], {
            stdio: ['pipe', 'pipe', 'pipe']
        });
        
        checkProcess.stdout.on('data', (data) => {
            console.log('‚úÖ n8n-mcp „Éê„Éº„Ç∏„Éß„É≥:', data.toString().trim());
        });

        checkProcess.stderr.on('data', (data) => {
            console.log('üìã n8n-mcp ÊÉÖÂ†±:', data.toString().trim());
        });

        setTimeout(() => {
            checkProcess.kill();
            console.log('\n‚úÖ n8n-MCPÂü∫Êú¨Âãï‰ΩúÁ¢∫Ë™çÂÆå‰∫Ü');
            console.log('\nüìã Claude Desktop„Åß„ÅÆ‰ΩøÁî®ÊñπÊ≥ï:');
            console.log('1. ~/.claude/claude_desktop_config.json „Å´Ë®≠ÂÆö„ÇíËøΩÂä†');
            console.log('2. Claude Desktop„ÇíÂÜçËµ∑Âãï');
            console.log('3. "n8n-mcp„ÉÑ„Éº„É´„ÅßHTTPRequest„Éé„Éº„Éâ„ÅÆÊÉÖÂ†±„ÇíÊïô„Åà„Å¶" „Å®Ë≥™Âïè');
        }, 3000);
        
    } catch (error) {
        console.error('‚ùå „ÉÜ„Çπ„ÉàÂÆüË°å„Ç®„É©„Éº:', error);
    }
}

if (require.main === module) {
    main().catch(console.error);
}

module.exports = N8nMcpTester;